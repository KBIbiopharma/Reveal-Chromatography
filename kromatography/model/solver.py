import numpy
from traits.api import Array, Enum, HasStrictTraits, Instance, Int

from app_common.traits.custom_trait_factories import PositiveInt
from .schur_solver import SchurSolver
from .time_integrator import TimeIntegrator

SOLVER_TYPES = ["DEFAULT_SOLVER"]

DEFAULT_NUM_TIMES = 2000


class Solver(HasStrictTraits):
    """ Solver parameters.
    """
    # -------------------------------------------------------------------------
    # Solver traits
    # -------------------------------------------------------------------------

    #: Number of used OpenMP threads
    nthreads = PositiveInt(exclude_low=True)

    #: Specifies the verbosity of the logging output (Only errors; warning
    #: and errors; info and warnings and errors, etc.)
    log_level = Enum(['INFO', 'WARNING', 'ERROR', 'DEBUG1', 'DEBUG2',
                      'TRACE1', 'TRACE2'])

    #: Print configuration message before simulation
    print_config = Enum([1, 0])

    #: Print list of parameters before simulation
    print_paramlist = Enum([0, 1])

    #: Print current state of simulation
    print_progress = Enum([1, 0])

    #: Print integrator statistics after each section
    print_statistics = Enum([1, 0])

    #: Print timing information after simulation
    print_timing = Enum([1, 0])

    #: Use analytically computed jacobian matrix (faster) instead of jacobian
    #: generated by algorithmic differentiation (slower)
    use_analytic_jacobian = Enum([1, 0])

    #: A integer with the number of time-points at which a solution is desired
    number_user_solution_points = Int(DEFAULT_NUM_TIMES)

    #: A vector with timepoints at which a solution is desired
    user_solution_times = Array(dtype=float, shape=(None,))

    #: Write solutions at times specified by USER_SOLUTION_TIMES
    #: (write integration timepoints otherwise)
    write_at_user_times = Enum([0, 1])

    #: Write times at which a solution was produced
    write_solution_times = Enum([1, 0])

    #: Write solutions at column inlet (boundary condition)
    write_solution_column_inlet = Enum([1, 0])

    #: Write solutions at column outlet (chromatograms)
    write_solution_column_outlet = Enum([1, 0])

    #: Write all (intermediate) solutions
    write_solution_all = Enum([1, 0])

    #: Write full solution state vector at last time point
    write_solution_last = Enum([0, 1])

    #: Write sensitivity data at column outlet
    write_sens_column_outlet = Enum([0, 1])

    #: Write all (intermediate) sensitivity data
    write_sens_all = Enum([0, 1])

    #: Write sensitivity data at column outlet
    write_sens_last = Enum([0, 1])

    #: Print current state of simulation
    schur_solver = Instance(SchurSolver, args=())

    #: Print current state of simulation
    time_integrator = Instance(TimeIntegrator, args=())

    # -------------------------------------------------------------------------
    # Methods
    # -------------------------------------------------------------------------

    def calculate_user_solution_times(self, end_time, start_time=0.0):
        self.user_solution_times = \
            numpy.linspace(start_time, float(end_time),
                           self.number_user_solution_points)
        self.write_at_user_times = 1

    def _nthreads_default(self):
        from kromatography.utils.app_utils import get_preferences
        prefs = get_preferences()
        return prefs.solver_preferences.cadet_num_threads
